/*\
title: $:/plugins/inmysocks/TWederation/communications-daemon.js
type: application/javascript
module-type: startup

This is the background process that is in charge of xmlhttprequests and handling responses from external sources.

\*/
(function () {

	/*jslint node: true, browser: true */
	/*global $tw: false */
	"use strict";

	// Export name and synchronous status
	exports.name = "communications-daemon";
	exports.platforms = ["browser"];
	exports.after = ["startup"];
	exports.synchronous = true;

	var Wiki = require("$:/core/modules/wiki.js");

	$tw.wiki.CommunicationsHandlerTypes = $tw.wiki.CommunicationsHandlerTypes || {};
	$tw.wiki.CommunicationsHandler = $tw.wiki.CommunicationsHandler || {};
	$tw.wiki.PendingCommunicationsRequest = 0;

	// Configuration tiddler
	var CONFIGURATION_TIDDLER = "$:/plugins/inmysocks/TWederation/CommunicationsDaemonSettings";
	var configurationTiddler = $tw.wiki.getTiddler(CONFIGURATION_TIDDLER);

	//This function gets called whenever something is added to the communications queue or a response is heard from an outside source to a previous request.
	function ProcessCommunicationsQueue() {
		if (Object.keys($tw.wiki.event_queue).length !== 0 && !$tw.wiki.PendingCommunicationsRequest) {
			//send the next request if there is one and no request is currently pending
			$tw.wiki.communicationWorker.postMessage($tw.wiki.event_queue[Object.keys($tw.wiki.event_queue)[0]].data);
			/*
			if (typeof $tw.wiki.CommunicationsHandler[$tw.wiki.event_queue[Object.keys($tw.wiki.event_queue)[0]].type] === 'function') {
				console.log('7');
				$tw.wiki.CommunicationsHandler[$tw.wiki.event_queue[Object.keys($tw.wiki.event_queue)[0]].type]($tw.wiki.event_queue[Object.keys($tw.wiki.event_queue)[0]].data);
			}
			*/
		}
	}

	$tw.wiki.communicationWorkerCode ='function loadIFrame(url,callback) {var iframeInfo = $tw.browserMessaging.iframeInfoMap[url];if(iframeInfo) {callback(null,iframeInfo);} else {var iframe = document.createElement("iframe"),iframeInfo = {url: url,status: "loading",domNode: iframe};$tw.browserMessaging.iframeInfoMap[url] = iframeInfo;iframe.style.display = "none";document.body.appendChild(iframe);iframe.onload = function() {iframeInfo.status = "loaded";callback(null,iframeInfo);};iframe.onerror = function() {callback("Cannot load iframe");};try {iframe.src = url;} catch(ex) {callback(ex);}}}function closeIFrame(url) {var iframe = document.body.getElementsByTagName("iframe");for (var j = 0; j <iframe.length; j++) {if (iframe[j].src === url) {document.body.removeChild(iframe[j]);$tw.browserMessaging.iframeInfoMap[url] = null;}}};self.addEventListener("message",function listener(event){switch(event.data.verb) {case "DELIVER_BUNDLE":self.postMessage(event.data);closeIFrame(event.data.origin);break;}},false);onmessage = function(e) {console.log("7");var paramObject = e.data.paramObject || {},url = paramObject.url;console.log(e.data);if(url) {loadIFrame(url,function(err,iframeInfo) {if(err) {alert("Error loading tiddler bundle: " + url);} else {console.log(e.data.paramObject);iframeInfo.domNode.contentWindow.postMessage({verb: "BUNDLE_REQUEST",filter: e.data.paramObject.filter,bundlename: e.data.paramObject.bundleName,separator: e.data.paramObject.separator,destination: url,bundleFunction: e.data.paramObject.packingFunction,sender: e.data.paramObject.sender,recipient: e.data.paramObject.recipient,previousTime: e.data.paramObject.previousTime}, "*");}});}}';

	exports.startup = function() {
		//This creates the communication web worker
		var workerTiddler = $tw.wiki.getTiddler('$:/plugins/inmysocks/TWederation/WorkerJavaScript');
		//var workerBlob = new Blob([$tw.wiki.communicationWorkerCode],{type: "text/javascript"});

		var workerBlob = new Blob([workerTiddler.getFieldString('text')],{type: "text/javascript"});

		$tw.wiki.communicationWorker = new Worker(URL.createObjectURL(workerBlob));
		$tw.wiki.communicationWorker.onmessage = $tw.wiki.handleWorkerResponse;
		//$tw.wiki.communicationWorker.postMessage();

		/*
		This will be the object that holds the event queue information. It will hold pending requests to be sent. Requests will be added using the tm-send-request message and after being sent the daemon will wait for a response (or a timeout) before moving on to the next request. This is to prevent collisions from responses. It is probably better to create web workers to service each request so we can do multiple requests simultaneously (limit the number of simultaneous workers), but I need to make sure that web workers won't cause other problems by being created using blobs and data uris on https servers.

		The structure of each element should be {url, xmlhttprequest data} for  now, this may get updated later.
		*/
		$tw.wiki.event_queue = $tw.wiki.event_queue || {};

		// Reset the values when any of the tiddlers change.
		$tw.rootWidget.addEventListener("tm-send-request",function(event) {
			//If the configuration changes do a full refresh, otherwise just refresh the changed expression.
			var paramObject = event.paramObject || {};
			var request_type = paramObject.request_type;

			if (request_type) {
				if (typeof $tw.wiki.CommunicationsHandlerTypes[request_type] === 'function') {
					$tw.wiki.CommunicationsHandlerTypes[request_type](event);
				} else {
					console.log('No handler exists for that type of request.');
				}
			} else {
				console.log('No request type given.');
			}
			ProcessCommunicationsQueue();
		});

		//With only one handler here this semes a bit clunky, but by making it this way we can have plugins add different event types that can be handled by the same extensible code without changing the core.
		$tw.wiki.CommunicationsHandlerTypes['request_bundle'] = function(event) {
			if ($tw.wiki.event_queue[event.paramObject.url]) {
				//There is already a queued request for that url. Ignore it for now to prevent repeated requests but we need to come up with a more elegant way to handle this in the future.
				console.log('There is already a request for that URL');
			} else {
				//The event is placed into the event queue object to be handled by the daemon
				$tw.wiki.event_queue[event.paramObject.url] = {'type':'request_bundle','data':event};
				console.log($tw.wiki.event_queue);
			}
		};

		$tw.wiki.CommunicationsHandler['request_bundle'] = function(event) {
		    var paramObject = event.paramObject || {},
				url = paramObject.url;
			if(url) {
		    	loadIFrame(url,function(err,iframeInfo) {
					if(err) {
						alert("Error loading tiddler bundle: " + url);
					} else {
						console.log(event.paramObject);
	    				iframeInfo.domNode.contentWindow.postMessage({
	    					verb: "BUNDLE_REQUEST",
	    					filter: event.paramObject.filter,
	    					bundlename: event.paramObject.bundleName,
	    					separator: event.paramObject.separator,
	    					destination: url,
	    					bundleFunction: event.paramObject.packingFunction,
	    					sender: event.paramObject.sender,
	    					recipient: event.paramObject.recipient,
	    					previousTime: event.paramObject.previousTime
	    				}, "*");
	    			}
	    		});
	    	}
			$tw.wiki.PendingCommunicationsRequest = 1;
	    };
	};

	$tw.wiki.handleWorkerResponse = function(event) {
		console.log(event);
		//Check if the bundle was sent from a recognized source
		if ($tw.wiki.recognizedSources[event.origin]) {
			//Check the type of bundle that was sent and pick the appropriate handler based on the type
			if (typeof $tw.wiki.bundleHandler[event.data.type] === 'function') {
				$tw.wiki.bundleHandler[event.data.type](event);
			} else {
				//If no recognized type is given make the bundle plain text to be safe.
				event.data.bundle.type = 'text/plain';
				console.log('unrecognized source');
				$tw.wiki.addTiddler(new $tw.Tiddler(event.data.bundle));
			}
		} else {
			//If the source isn't recognized than set the tiddler as plain text and marke it as having an unrecognized source.
			event.data.bundle.type = 'text/plain';
			event.data.bundle.source = 'unrecognized';
			$tw.wiki.addTiddler(new $tw.Tiddler(event.data.bundle));
		}
		$tw.wiki.addTiddler(new $tw.Tiddler($tw.wiki.getCreationFields(),{title: '$:/TiddlerBundleData/' + event.data.bundle.title, list: event.data.bundle.list, text: "Source: {{!!source}}<br>Tiddlers: <$list filter='[list[]]'><$link to=<<currentTiddler>>><$view field='title'/></$link>, </$list>", tags: '$:/tags/TiddlerBundle', source: event.origin}));
		closeIFrame(event.data.origin);
	};

})();
